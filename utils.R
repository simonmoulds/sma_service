## Author : Simon Moulds, Imperial College London
## Date   : May 2019

get_crop_params = function(db, crop) {
    ## Function to retrieve the set of parameters matching a
    ## particular crop from a data frame.
    row_ix = which(db$Crop %in% crop)
    x = db[row_ix,]
    x = as.list(x)
    x
}

is_leap_year = function(year) {
    ## Function which returns a boolean indicating whether
    ## the provided year(s) is a leap year.
    return(ifelse((year %%4 == 0 & year %%100 != 0) | year %%400 == 0, TRUE, FALSE))
}

is_growing_season = function(time, pd, hd) {
    
    time = as.POSIXlt(time)
    nt = length(time)
    day = time$yday + 1
    year = time$year + 1900
    leap = is_leap_year(year)
    pd_rep = rep(pd, nt)
    hd_rep = rep(hd, nt)

    ## account for leap years in pd/hd arrays. We assume that
    ## in a leap year the dd/mm is maintained; hence we must
    ## add one to the Julian day.
    if (pd > 59) {
        pd_rep[leap] = pd_rep[leap] + 1
    }
    
    if (hd > 59) {
        hd_rep[leap] = hd_rep[leap] + 1
    }

    ## growing season
    if (pd < hd) {
        growing_season = ((day >= pd_rep) & (day <= hd_rep))
    } else {
        growing_season = ((day >= pd_rep) | (day <= hd_rep))
    }
    growing_season
}

compute_kc = function(time, pd, hd, crop_params, default_val=0.5) {
    ## Function to generate an array of Kc values for the
    ## provided time series.
    
    time = as.POSIXlt(time)
    nt = length(time)

    ## extend time series by 365 to ensure we get the full
    ## season (because we are potentially dealing with
    ## a time series which is updated in realtime, it is
    ## likely that it will not include data for the full
    ## growing season); a requirement because some Kc values
    ## are generated by linear interpolation.
    time_ext = seq.POSIXt(
        time[1],
        by="1 day",
        length.out=nt + 365
    )
    time_ext = as.POSIXlt(time_ext)
    nt_ext = length(time_ext)
    day = time_ext$yday + 1
    year = time_ext$year + 1900
    leap = is_leap_year(year)
    days_in_year = rep(365, nt_ext)
    days_in_year[leap] = days_in_year[leap] + 1

    ## convert pd/hd to vectors, with one value for each
    ## time point in the extended time series
    pd_rep = rep(pd, nt_ext)
    hd_rep = rep(hd, nt_ext)

    ## account for leap years in pd/hd arrays. We assume that
    ## in a leap year the dd/mm is maintained; hence we must
    ## add one to the Julian day.
    if (pd > 59) {
        pd_rep[leap] = pd_rep[leap] + 1
    }
    
    if (hd > 59) {
        hd_rep[leap] = hd_rep[leap] + 1
    }

    ## growing season
    if (pd < hd) {
        growing_season = ((day >= pd_rep) & (day <= hd_rep))
        growing_season_duration = (hd_rep - pd_rep) + 1
    } else {
        growing_season = ((day >= pd_rep) | (day <= hd_rep))
        growing_season_duration = (hd_rep + days_in_year - pd_rep) + 1
    }
    growing_season_duration[!growing_season] = NA

    pd_logical = (day == pd_rep)
    dap = rep(NA, nt_ext)
    dap[pd_logical] = seq(1, nt_ext)[pd_logical]
    dap = zoo::na.locf(dap, na.rm=FALSE)
    dap = seq(1, nt_ext) - dap
    dap[!growing_season] = NA
    dap = dap + 1

    ## Generate an array of values showing the daily growing
    ## season progress, such that the planting date has a
    ## value of 1/(number of days in growing season) and
    ## the harvest date has a value of 1. Outside the growing
    ## season we assign an arbitrarily high (>1) value.
    frac = dap / growing_season_duration
    frac[!growing_season] = 10          # arbitrary high val

    ## Generate array of accumulated relative growth stage
    ## durations. These values are compared to the daily
    ## growing season progress ('frac'), to map days to a
    ## particular growth stage. 
    L_accum = cumsum(
        c(crop_params$L_ini,
          crop_params$L_dev,
          crop_params$L_mid,
          crop_params$L_late)
    )
    
    ## assign Kc vals by mapping individual days in the
    ## growing season to the Kc value matching the
    ## corresponding growth stage. Values between
    ## Kc_ini -> Kc_mid, and Kc_mid -> Kc_end, are
    ## assigned by linear interpolation.
    kc = rep(NA, nt_ext)
    kc[!growing_season] = default_val
    kc[(frac <= L_accum[1])] = crop_params$Kc_ini
    kc[(frac > L_accum[2]) & (frac <= L_accum[3])] = crop_params$Kc_mid
    kc[frac == 1.0] = crop_params$Kc_end
    kc = zoo::na.approx(kc)

    ## return to original size
    kc = kc[1:nt]
    kc
}

compute_zr = function(time, pd, hd, crop_params, default_val=1) {
    time = as.POSIXlt(time)
    nt = length(time)
    year = time$year + 1900
    growing_season = is_growing_season(time, pd, hd)
    zr = rep(default_val, nt)
    zr[growing_season] = crop_params$rd_rain
    zr = zr * 1000                      # m -> mm
    zr
}

compute_p_std = function(time, pd, hd, crop_params, default_val=0.55) {
    time = as.POSIXlt(time)
    nt = length(time)
    year = time$year
    growing_season = is_growing_season(time, pd, hd)
    p_std = rep(default_val, nt)
    p_std[growing_season] = crop_params$p_std
    p_std
}
